// This header contains necessary structures for setting up correct screen modes,
// pixel formats, audio formats, and so on.

#include <windows.h>
#include <GL/gl.h>
#include <mmsystem.h>
#include <mmreg.h>

#include "glext.h"

// this file is auto generated by 4klang
#include "4klang/4klang.h"

// global resolution
#define XRES 1280
#define YRES 720

#pragma data_seg(".pixelfmt")
static const PIXELFORMATDESCRIPTOR pfd = {
	sizeof(PIXELFORMATDESCRIPTOR), 1, PFD_DRAW_TO_WINDOW|PFD_SUPPORT_OPENGL|PFD_DOUBLEBUFFER, PFD_TYPE_RGBA,
	32, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 32, 0, 0, PFD_MAIN_PLANE, 0, 0, 0, 0 };

#pragma data_seg(".screensettings")
static DEVMODE screenSettings = { {0},
	#if _MSC_VER < 1400 // Visual C++ 6.0
	0,0,148,0,0x001c0000,{0},0,0,0,0,0,0,0,0,0,{0},0,32,XRES,YRES,0,0,      
	#else
	0,0,156,0,0x001c0000,{0},0,0,0,0,0,{0},0,32,XRES,YRES,{0}, 0, 
	#endif
	#if(WINVER >= 0x0400)
	0,0,0,0,0,0,
	#if (WINVER >= 0x0500) || (_WIN32_WINNT >= 0x0400)
	0,0
	#endif
	#endif
};

#pragma data_seg(".4klangout")
static SAMPLE_TYPE lpSoundBuffer[MAX_SAMPLES * 2];
static HWAVEOUT hWaveOut;

#pragma data_seg(".wavefmt")
static WAVEFORMATEX WaveFMT =
{
#ifdef FLOAT_32BIT	
	WAVE_FORMAT_IEEE_FLOAT,
#else
	WAVE_FORMAT_PCM,
#endif		
	2,                                   // channels
	SAMPLE_RATE,                         // samples per sec
	SAMPLE_RATE*sizeof(SAMPLE_TYPE) * 2, // bytes per sec
	sizeof(SAMPLE_TYPE) * 2,             // block alignment;
	sizeof(SAMPLE_TYPE) * 8,             // bits per sample
	0                                    // extension not needed
};

#pragma data_seg(".wavehdr")
static WAVEHDR WaveHDR =
{
	(LPSTR)lpSoundBuffer, MAX_SAMPLES*sizeof(SAMPLE_TYPE)*2,0,0,0,0,0,0
};

static MMTIME MMTime =
{
	TIME_SAMPLES, 0
};

//extern "C" int _fltused = 0;

#ifdef EDITOR_CONTROLS
	#define INIT_HUD_GL() \
		GLuint hud_fbo; \
		((PFNGLGENFRAMEBUFFERSPROC)wglGetProcAddress("glGenFramebuffers"))(1, &hud_fbo); \
		CHECK_ERRORS(); \
		unsigned int hud_tex; \
		glGenTextures(1, &hud_tex); \
		CHECK_ERRORS(); \
		glBindTexture(GL_TEXTURE_2D, hud_tex); \
		CHECK_ERRORS(); \
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); \
		CHECK_ERRORS(); \
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); \
		CHECK_ERRORS(); \
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); \
		CHECK_ERRORS(); \
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE); \
		CHECK_ERRORS(); \
		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, XRES, YRES, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL); \
		CHECK_ERRORS(); \
		glBindTexture(GL_TEXTURE_2D, 0); \
		CHECK_ERRORS(); \
		((PFNGLFRAMEBUFFERTEXTURE2DPROC)wglGetProcAddress("glFramebufferTexture2D"))(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, hud_tex, 0); \
		CHECK_ERRORS();

	#define DRAW_HUD_GL() \
		((PFNGLACTIVETEXTUREPROC)wglGetProcAddress("glActiveTexture"))(GL_TEXTURE0); \
		CHECK_ERRORS(); \
		((PFNGLBINDFRAMEBUFFERPROC)wglGetProcAddress("glBindFramebuffer"))(GL_FRAMEBUFFER, hud_fbo); \
		CHECK_ERRORS(); \
		glDrawBuffer(GL_COLOR_ATTACHMENT0); \
		CHECK_ERRORS(); \
		glBindTexture(GL_TEXTURE_2D, hud_tex); \
		CHECK_ERRORS(); \
		((PFNGLUSEPROGRAMPROC)wglGetProcAddress("glUseProgram"))(input1_program); \
		CHECK_ERRORS(); \
		((PFNGLUNIFORM1IPROC)wglGetProcAddress("glUniform1i"))(0, current_time); \
		((PFNGLUNIFORM2FPROC)wglGetProcAddress("glUniform2f"))(1, (float)XRES, (float)YRES); \
		CHECK_ERRORS(); \
		glRects(-1, -1, 1, 1); \
		CHECK_ERRORS(); \
		glBindTexture(GL_TEXTURE_2D, 0); \
		CHECK_ERRORS(); \
		((PFNGLBINDFRAMEBUFFERPROC)wglGetProcAddress("glBindFramebuffer"))(GL_FRAMEBUFFER, 0); \
		CHECK_ERRORS();

const char* hud = \
"#version 130\n"
"uniform vec2 resolution;"
"out vec4 i;"
"float hash(float c){return fract(sin(dot(c, 12.9898)) * 43758.5453);}\n"
"void main(){"
	"vec2 uv = gl_FragCoord.xy/resolution;"
	"i.rgb = vec3(0.5,0.8,0.9);"
	"i.a = uv.y<0.6&&uv.y>0.4?1.0:0.0;"
"}";

#endif